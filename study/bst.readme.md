### 🌲 **Traversal Algorithms** (to visit every node)

1. **In-Order Traversal (Left → Root → Right)**

   - Used in BSTs to get values in **sorted order**.

2. **Pre-Order Traversal (Root → Left → Right)**

   - Useful for copying trees or creating prefix expressions.

3. **Post-Order Traversal (Left → Right → Root)**

   - Used for deleting or freeing trees, and evaluating expressions.

4. **Level-Order Traversal (Breadth-First Search)**

   - Visit nodes **level by level** using a queue.

---

### 🔍 **Search and Insert**

5. **Search in Binary Tree / BST**

   - Check if a value exists, using tree structure.

6. **Insert into Binary Tree / BST**

   - Add a node at the correct position.

---

### ❌ **Delete a Node (BST-specific)**

- Complex because you must handle 3 cases:

  - Node has no children.
  - Node has one child.
  - Node has two children.

---

### 📏 **Tree Properties**

7. **Find Height / Depth**

   - Max number of edges from root to a leaf.

8. **Count Nodes / Leaves**

   - Total nodes or leaf nodes in the tree.

---

### ✅ **Validation Algorithms**

9. **Check if a Tree is a BST**

   - Verify ordering rules hold.

10. **Check if Tree is Balanced (AVL logic)**

- Difference in height between subtrees is not more than 1.

---

### 🔁 **Construct Trees**

11. **Build Tree from In-Order and Pre/Post-Order**

- Reconstruct the original tree from traversal sequences.

---

### ♻️ **Mirror or Invert Tree**

- Swap left and right children at every level.

---

These are the **core binary tree algorithms** you’ll need for interviews, data structures courses, and practical applications.

Would you like these organized in a diagram or mind map?
